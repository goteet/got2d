#pragma once
#include <g2dconfig.h>
#include <g2dinput.h>
#include <gmlvector.h>
#include <gmlmatrix.h>
#include <gmlaabb.h>
#include <gmlrect.h>
namespace g2d
{
	constexpr uint32_t DEF_VISIBLE_MASK = 0xFFFFFFFF;
	constexpr int DEF_COMPONENT_ORDER = 0x5000;

	class Component;
	class Camera;
	class SceneNode;
	class Scene;


	// 组件基类，挂在场景节点上，一个SceneNode可以挂多个Component
	// 重载接口已获得自定义事件响应
	class G2DAPI Component : public GObject
	{
	public:
		// 用户自定义实体需要组件的内存释放的接口
		// 引擎内部会调用这个接口释放Component资源
		// 只会在析构时候被调用
		virtual void Release() = 0;

		// 局部坐标系下组件的包围盒大小
		virtual const gml::aabb2d& GetLocalAABB() const { static gml::aabb2d b; return b; }

		// 节点在世界空间中包围盒的大小
		// 默认实现用世界矩阵变换局部坐标系下的包围盒
		virtual gml::aabb2d GetWorldAABB() const;

		// 用户重载这个函数以修正组件执行顺序
		// 这个值越大执行顺序约靠后
		virtual int GetExecuteOrder() const { return DEF_COMPONENT_ORDER; }

		// 组件挂载的的场景节点
		// 这个接口一般提供给用户自定义的component内部获取node相关属性
		SceneNode* GetSceneNode() const { return m_sceneNode; }

		// 获取所在场景节点的摄像机可见Flag
		// 这个是一个转发消息的快捷函数。
		uint32_t GetVisibleMask() const;

	public:
		// 节点被成功构造的事件
		// 一般初始化代码写这个事件里
		virtual void OnInitial() { }

		// 节点进行更新的事件
		// 一般每帧逻辑更新写这个事件里
		virtual void OnUpdate(uint32_t deltaTime) { }

		// 节点进行渲染的事件
		// 渲染节点的时候需要用户把render request加入到渲染队列中
		virtual void OnRender() { }

		// 节点局部旋转更新事件
		virtual void OnRotate(gml::radian r) { }

		// 节点局部缩放更新事件
		virtual void OnScale(const gml::vec2& newScaler) { }

		// 节点局部位置更新事件
		virtual void OnMove(const gml::vec2& newPos) { }

		// 用户输入消息事件
		// 单纯的获取原始消息，消息会被转化成以下特殊事件
		virtual void OnMessage(const g2d::Message& message) { }

		// 节点局部坐标变化之后，第一次更新的事件
		// 一般AABB的变换在这里计算。
		// 顺序在 OnUpdate之后
		virtual void OnUpdateMatrixChanged() { }

		// 当光标碰到节点对象(Entity)的时候触发
		// 参数是前一个光标悬停的对象
		// 直接从未悬停状态下触碰对象时参数为空
		virtual void OnCursorEnterFrom(SceneNode* adjacency, const g2d::Mouse&, const g2d::Keyboard&) { }

		// 当光标悬停在物体上的时候持续触发
		virtual void OnCursorHovering(const g2d::Mouse&, const g2d::Keyboard&) { }

		// 当光标离开节点对象(Entity)的时候触发
		// 参数是当前光标悬停的对象
		// 如果离开实体后光标没有触碰对象，此参数为空
		virtual void OnCursorLeaveTo(SceneNode* adjacency, const g2d::Mouse&, const g2d::Keyboard&) { }

		// 单击鼠标事件
		virtual void OnLClick(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnRClick(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnMClick(const g2d::Mouse&, const g2d::Keyboard&) { }

		// 双击鼠标的事件
		virtual void OnLDoubleClick(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnRDoubleClick(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnMDoubleClick(const g2d::Mouse&, const g2d::Keyboard&) { }

		// 光标拖拽开始
		virtual void OnLDragBegin(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnRDragBegin(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnMDragBegin(const g2d::Mouse&, const g2d::Keyboard&) { }

		// 没有触碰到别的物体的时候，光标拖拽中
		virtual void OnLDragging(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnRDragging(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnMDragging(const g2d::Mouse&, const g2d::Keyboard&) { }

		// 没有触碰到别的物体的时候，鼠标拖拽结时
		virtual void OnLDragEnd(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnRDragEnd(const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnMDragEnd(const g2d::Mouse&, const g2d::Keyboard&) { }

		// 光标触碰到别的物体的时候，鼠标拖拽中
		// 如果dropped 是空的话，会把消息转发到OnDragging
		virtual void OnLDropping(SceneNode* dropped, const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnRDropping(SceneNode* dropped, const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnMDropping(SceneNode* dropped, const g2d::Mouse&, const g2d::Keyboard&) { }

		// 光标触碰到别的物体的时候，鼠标拖拽结束
		virtual void OnLDropTo(SceneNode* dropped, const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnRDropTo(SceneNode* dropped, const g2d::Mouse&, const g2d::Keyboard&) { }
		virtual void OnMDropTo(SceneNode* dropped, const g2d::Mouse&, const g2d::Keyboard&) { }

		// 键位被触发，与持续按下的情况互斥
		virtual void OnKeyPress(KeyCode key, const g2d::Mouse&, const g2d::Keyboard& keyboard) { }

		// 键位被持续按下的第一下
		virtual void OnKeyPressingBegin(KeyCode key, const g2d::Mouse&, const g2d::Keyboard& keyboard) { }

		// 键位被持续按下
		virtual void OnKeyPressing(KeyCode key, const g2d::Mouse&, const g2d::Keyboard& keyboard) { }

		// 键位被持续按下的最后一下
		virtual void OnKeyPressingEnd(KeyCode key, const g2d::Mouse&, const g2d::Keyboard& keyboard) { }

	public://内部使用

		// 初始化场景节点的时候设置关联
		void SetSceneNode(g2d::SceneNode* node);

		// 当节点顺序变更的时候，引擎会调用此接口修正渲染顺序
		void SetRenderingOrder(uint32_t& order);

		// 渲染的时候根据顺序排列组件
		uint32_t GetRenderingOrder() { return m_renderingOrder; }

	private:
		SceneNode* m_sceneNode = nullptr;
		uint32_t m_renderingOrder = 0xFFFFFFFF;
	};

	// 一张图片
	class G2DAPI Quad : public Component
	{
	public:
		static Quad* Create();

		// 设置 Quad Mesh 大小
		virtual g2d::Quad* SetSize(const gml::vec2& size) = 0;

		// 获取 Quad Mesh 大小
		virtual const gml::vec2& GetSize() const = 0;
	};

	//用于场景查找可见物体，进行渲染的摄像机
	class G2DAPI Camera : public Component
	{
	public:
		// 摄像机在场景中的编号
		// 默认摄像机的编号为0
		virtual uint32_t GetID() const = 0;

		// 摄像机位置
		// 返回自身，可以使用链式设置
		virtual Camera* SetPosition(const gml::vec2& p) = 0;

		// 摄像机镜头缩放
		// 返回自身，可以使用链式设置
		virtual Camera* SetScale(const gml::vec2& s) = 0;

		// 摄像机 Roll 旋转
		// 返回自身，可以使用链式设置
		virtual Camera* SetRotation(gml::radian r) = 0;

		// 设置渲染顺序，多个摄像机会根据这个渲染顺序进行排列
		// 顺序越小越优先渲染
		virtual void SetRenderingOrder(int order) = 0;

		// 查找可见物体Flag
		virtual void SetVisibleMask(uint32_t mask) = 0;

		// 是否启用摄像机，如果不启用，摄像机不会查找物体进行渲染
		virtual void SetActivity(bool activity) = 0;

		// 渲染系统需要的视矩阵
		virtual const gml::mat32& GetViewMatrix() const = 0;

		// 判断一个aabb是否会被摄像机看见
		virtual bool TestVisible(const gml::aabb2d& bounding) const = 0;

		// 判断一个Component是否会被摄像机看见
		// aabb为一个点，mask不匹配视为不可见
		virtual bool TestVisible(Component& component) const = 0;

		// 查找可见物体Flag
		virtual uint32_t GetVisibleMask() const = 0;

		// 渲染顺序
		virtual int GetRenderingOrder() const = 0;

		// 摄像机是否被启用
		virtual bool IsActivity() const = 0;

		virtual gml::vec2 ScreenToWorld(const gml::coord& pos) const = 0;

		virtual gml::coord WorldToScreen(const gml::vec2& pos) const = 0;
	};

	// 场景节点，在场景中是一个以树形形式组成
	class G2DAPI SceneNode : public GObject
	{
	public:
		// 析构节点，把当前节点从树种删除。
		// 会同时把组件对象全部删除。
		virtual void Release() = 0;

		// 节点所在场景
		// Scene作为根节点会返回自身
		virtual Scene* GetScene() const = 0;

		// 获取节点的父节点
		// Scene作为根节点会返回nullptr
		virtual SceneNode* GetParentNode() const = 0;

		// 获取同级节点的下一个节点
		// 同级最后一个节点返回nullptr
		virtual SceneNode* GetPrevSiblingNode() const = 0;

		// 获取同级节点的上一个节点
		// 同级第一个节点返回nullptr
		virtual SceneNode* GetNextSiblingNode() const = 0;

		// 获取第一个孩子
		// 如果没有孩子则返回nullptr
		virtual g2d::SceneNode* FirstChild() const = 0;

		// 获取最后一个孩子
		// 如果没有孩子则返回nullptr
		virtual g2d::SceneNode* LastChild() const = 0;

		// 使用索引获得子节点
		virtual g2d::SceneNode* GetChildByIndex(uint32_t index) const = 0;

		// 获取子节点的数目
		virtual uint32_t GetChildCount() const = 0;

		// 创建子节点
		virtual SceneNode* CreateChild() = 0;

		// 把当前节点移动到同级最后一个
		// 以保证第一个渲染！
		virtual void MoveToFront() = 0;

		// 把当前节点移动到同级第一个
		// 以保证是最后一个渲染！
		virtual void MoveToBack() = 0;

		// 跟同级前一个节点交换位置，以保证渲染顺序
		// 当节点是同级第一个的时候什么也不做
		virtual void MovePrev() = 0;

		// 跟同级后一个节点交换位置，以保证渲染顺序
		// 当节点是同级最后一个的时候什么也不做
		virtual void MoveNext() = 0;

		// 添加组件接口
		virtual bool AddComponent(Component*, bool autoRelease) = 0;

		// 移除确定组件
		virtual bool RemoveComponent(Component*) = 0;

		// 移除确定组件，并且强制不调用Release接口
		virtual bool RemoveComponentWithoutRelease(Component*) = 0;

		// 获取某个组件的释放条件，如果组件不存在，返回假。
		virtual bool IsComponentAutoRelease(Component*) const = 0;

		// 根据下标索引获取组件，
		// 注意， 不同组件会根据优先级变化，组件的索引是会发生改变的
		virtual Component* GetComponentByIndex(uint32_t index) const = 0;

		// 组件的个数
		virtual uint32_t GetComponentCount() const = 0;

		// 当前节点的局部矩阵
		virtual const gml::mat32& GetLocalMatrix() = 0;

		// 累乘上所有父节点之后的世界矩阵
		virtual const gml::mat32& GetWorldMatrix() = 0;

		// 设置节点的位置
		// 返回自身，可以使用链式设置
		virtual SceneNode* SetPosition(const gml::vec2& position) = 0;

		// 设置节点的世界位置，这个API会改变局部坐标
		// 返回自身，可以使用链式设置
		virtual g2d::SceneNode* SetWorldPosition(const gml::vec2& position) = 0;

		// 设置节点的中心偏移，会影响缩放
		// 返回自身，可以使用链式设置
		virtual SceneNode* SetPivot(const gml::vec2& pivot) = 0;

		// 设置节点的缩放
		// 返回自身，可以使用链式设置
		virtual SceneNode* SetScale(const gml::vec2& scale) = 0;

		// 设置节点的 Roll 旋转
		// 返回自身，可以使用链式设置
		virtual SceneNode* SetRotation(gml::radian r) = 0;

		// 手都设置是否可见，不可见的节点不会进行渲染
		virtual void SetVisible(bool) = 0;

		// 是否是固定节点
		// 固定节点会被加入到场景四叉树中
		// 优化可见判断速度
		virtual void SetStatic(bool) = 0;

		// 设置摄像机可见的 Mask
		virtual void SetVisibleMask(uint32_t mask, bool recursive) = 0;

		// 获得节点位置
		virtual const gml::vec2& GetPosition() const = 0;

		// 获得节点世界坐标的位置
		virtual gml::vec2 GetWorldPosition() = 0;

		// 获得节点中心偏移
		virtual const gml::vec2& GetPivot() const = 0;

		// 获得节点缩放
		virtual const gml::vec2& GetScale() const = 0;

		// 获得节点Roll旋转
		virtual gml::radian GetRotation() const = 0;

		// 获取当前节点是父亲的第几个节点
		virtual uint32_t GetChildIndex() const = 0;

		// 节点是否可见设置
		virtual bool IsVisible() const = 0;

		// 节点是否是固定的设置
		virtual bool IsStatic() const = 0;

		// 节点可见性Mask的设置
		virtual uint32_t GetVisibleMask() const = 0;

		// 把坐标转换节点局部空间内
		virtual gml::vec2 WorldToLocal(const gml::vec2& pos) = 0;

		// 把坐标转换节点同级的局部空间
		virtual gml::vec2 WorldToParent(const gml::vec2& pos) = 0;
	};

	// 根据类型获取
	template<typename T> T* FindComponent(SceneNode* node);

	class G2DAPI Scene : public GObject
	{
	public:
		// 创建的场景需要用户手动释放资源
		// 只能调用一次
		virtual void Release() = 0;

		// 获取第一个孩子
		// 如果没有孩子则返回nullptr
		virtual g2d::SceneNode* FirstChild() const = 0;

		// 获取最后一个孩子
		// 如果没有孩子则返回nullptr
		virtual g2d::SceneNode* LastChild() const = 0;

		// 使用索引获得子节点
		virtual g2d::SceneNode* GetChildByIndex(uint32_t index) const = 0;

		// 获取子节点的数目
		virtual uint32_t GetChildCount() const = 0;

		// 创建子节点
		virtual SceneNode* CreateChild() = 0;

		// 为场景创建一个摄像机
		virtual Camera* CreateCameraNode() = 0;

		// 获取默认的摄像机
		virtual Camera* GetMainCamera() const = 0;

		// 根据ID获取摄像机
		// 默认摄像机编号为0
		virtual Camera* GetCameraByIndex(uint32_t index) const = 0;

		// 获取摄像机的数目
		virtual uint32_t GetCameraCount() const = 0;

		// 把场景中的物体加入渲染队列
		// 需要用户主动调用
		virtual void Render() = 0;
	};

	template<typename T> T* FindComponent(SceneNode* node)
	{
		auto count = node->GetComponentCount();
		for (uint32_t i = 0; i < count; i++)
		{
			auto component = node->GetComponentByIndex(i);
			if (Is<T>(component)) return reinterpret_cast<T*>(component);
		}
		return nullptr;
	}
}
